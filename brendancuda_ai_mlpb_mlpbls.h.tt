#pragma once

#include <cuda_runtime.h>
#include <memory>
#include <bit>
#include "BSerializer/Serializer.h"
#include "brendancuda_rand_anyrng.h"
#include "brendancuda_ai.h"

namespace BrendanCUDA {
    namespace AI {
        namespace MLPB {
<# for (int i = 8; i <= 64; i <<= 1) { #>
<# for (int j = 8; j <= 64; j <<= 1) { #>
            class MLPBL<#= i #>T<#= j #> final {
            public:
                __host__ __device__ MLPBL<#= i #>T<#= j #>();
                __host__ MLPBL<#= i #>T<#= j #>(uint<#= i #>_t* Weights, uint<#= j #>_t* Bias, bool CopyFromHost);
                __device__ MLPBL<#= i #>T<#= j #>(uint<#= i #>_t* Weights, uint<#= j #>_t* Bias);
                __host__ __device__ MLPBL<#= i #>T<#= j #>(uint<#= i #>_t* Weights, uint<#= j #>_t Bias);
                __host__ __device__ void Dispose();
                __host__ __device__ uint<#= i #>_t* Weights() const;
                __host__ __device__ uint<#= i #>_t* Weight(size_t Index) const;
                __host__ __device__ uint<#= j #>_t* Bias() const;
                __host__ uint<#= i #>_t* GetWeights(bool CopyToHost) const;
                __device__ uint<#= i #>_t* GetWeights() const;
                __host__ void SetWeights(uint<#= i #>_t* Weights, bool CopyFromHost);
                __device__ void SetWeights(uint<#= i #>_t* Weights);
                __host__ __device__ uint<#= i #>_t GetWeight(size_t Index) const;
                __host__ __device__ void SetWeight(size_t Index, uint<#= i #>_t Weight);
                __host__ __device__ uint<#= j #>_t GetBias() const;
                __host__ __device__ void SetBias(uint<#= j #>_t Bias);
                __host__ __device__ uint<#= j #>_t Run(uint<#= i #>_t Input) const;
                __host__ __device__ uint64_t RunG(uint64_t Input) const;
                __host__ __device__ void CopyTo(MLPBL<#= i #>T<#= j #> Other) const;

                __host__ __device__ MLPBL<#= i #>T<#= j #> Clone() const;
                __host__ __device__ void RandomizeWFlips(uint32_t WeightsFlipProb, uint32_t BiasFlipProb, Random::AnyRNG<uint64_t> RNG);
                __host__ __device__ MLPBL<#= i #>T<#= j #> ReproduceWFlips(uint32_t WeightsFlipProb, uint32_t BiasFlipProb, Random::AnyRNG<uint64_t> RNG) const;
                __host__ __device__ void RandomizeWTargets(uint32_t WeightsEachFlipProb, uint32_t BiasFlipProb, Random::AnyRNG<uint64_t> RNG);
                __host__ __device__ MLPBL<#= i #>T<#= j #> ReproduceWTargets(uint32_t WeightsEachFlipProb, uint32_t BiasFlipProb, Random::AnyRNG<uint64_t> RNG) const;
                __host__ __device__ void RandomizeWMutations(uint32_t WeightsMutationProb, uint32_t WeightsProbOf1, uint32_t BiasMutationProb, uint32_t BiasProbOf1, Random::AnyRNG<uint64_t> RNG);
                __host__ __device__ MLPBL<#= i #>T<#= j #> ReproduceWMutations(uint32_t WeightsMutationProb, uint32_t WeightsProbOf1, uint32_t BiasMutationProb, uint32_t BiasProbOf1, Random::AnyRNG<uint64_t> RNG) const;

                size_t SerializedSize() const;
                void Serialize(void*& Data) const;
                static MLPBL<#= i #>T<#= j #> Deserialize(const void*& Data);
                static void Deserialize(const void*& Data, MLPBL<#= i #>T<#= j #>& Value);
            private:
                uint<#= i #>_t* weights;
                uint<#= j #>_t* bias;
            };
<# } } #>
        }
    }
}

<# for (int i = 8; i <= 64; i <<= 1) { #>
<# for (int j = 8; j <= 64; j <<= 1) { #>
size_t BrendanCUDA::AI::MLPB::MLPBL<#= i #>T<#= j #>::SerializedSize() const {
    return sizeof(uint<#= i #>_t) * <#= j #> + sizeof(uint<#= j #>_t);
}
void BrendanCUDA::AI::MLPB::MLPBL<#= i #>T<#= j #>::Serialize(void*& Data) const {
    if (std::endian::native == std::endian::little) {
        cudaMemcpy(Data, weights, sizeof(uint<#= i #>_t) * <#= j #>, cudaMemcpyDeviceToHost);
        Data = ((uint<#= i #>_t*)Data) + <#= j #>;
        cudaMemcpy(Data, bias, sizeof(uint<#= j #>_t), cudaMemcpyDeviceToHost);
        Data = ((uint<#= j #>_t*)Data) + 1;
    }
    else {
        cudaMemcpy(Data, weights, sizeof(uint<#= i #>_t) * <#= j #>, cudaMemcpyDeviceToHost);
        void* nd = ((uint<#= i #>_t*)Data) + <#= j #>;
        BSerializer::ToFromLittleEndian((uint<#= i #>_t*)Data, (uint<#= i #>_t*)nd);
        Data = nd;
        cudaMemcpy(Data, bias, sizeof(uint<#= j #>_t), cudaMemcpyDeviceToHost);
        uint<#= j #>_t& bref = *(uint<#= j #>_t*)Data;
        bref = BSerializer::ToFromLittleEndian(bref);
        Data = ((uint<#= j #>_t*)Data) + 1;
    }
}
BrendanCUDA::AI::MLPB::MLPBL<#= i #>T<#= j #> BrendanCUDA::AI::MLPB::MLPBL<#= i #>T<#= j #>::Deserialize(const void*& Data) {
    if (std::endian::native == std::endian::little) {
        MLPBL<#= i #>T<#= j #> mlpbl;
        cudaMemcpy(mlpbl.weights, Data, sizeof(uint<#= i #>_t) * <#= j #>, cudaMemcpyHostToDevice);
        Data = ((uint<#= i #>_t*)Data) + <#= j #>;
        cudaMemcpy(mlpbl.bias, Data, sizeof(uint<#= j #>_t), cudaMemcpyHostToDevice);
        Data = ((uint<#= j #>_t*)Data) + 1;
        return mlpbl;
    }
    else {
        MLPBL<#= i #>T<#= j #> mlpbl;
        cudaMemcpy(mlpbl.weights, Data, sizeof(uint<#= i #>_t) * <#= j #>, cudaMemcpyHostToDevice);
        void* nd = ((uint<#= i #>_t*)Data) + <#= j #>;
        BSerializer::ToFromLittleEndian((uint<#= i #>_t*)Data, (uint<#= i #>_t*)nd);
        Data = nd;
        cudaMemcpy(mlpbl.bias, Data, sizeof(uint<#= j #>_t), cudaMemcpyHostToDevice);
        uint<#= j #>_t& bref = *(uint<#= j #>_t*)Data;
        bref = BSerializer::ToFromLittleEndian(bref);
        Data = ((uint<#= j #>_t*)Data) + 1;
        return mlpbl;
    }
}
void BrendanCUDA::AI::MLPB::MLPBL<#= i #>T<#= j #>::Deserialize(const void*& Data, MLPBL<#= i #>T<#= j #>& Value) {
    Value = Deserialize(Data);
}
<# } } #>